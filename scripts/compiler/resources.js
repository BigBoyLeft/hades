import swc from '@swc/core';
import path from 'node:path';
import fs from 'node:fs';
import { sanitizePath, getAllModules, MODULE_FOLDER, globSync, writeFile } from '../lib/file.js';

const RESOURCES_FOLDER = 'server/resources';

let failedFiles = [];
let moduleDisablers = ['disabled'];

/**
 * @return {string[]}
 */
function getEnabledModules() {
    const modules = getAllModules();

    return modules.filter((module) => {
        const modulePath = sanitizePath(path.join(MODULE_FOLDER, module));

        for (const file of moduleDisablers) {
            const filePath = sanitizePath(path.join(modulePath, file));

            if (fs.existsSync(filePath)) {
                return false;
            }
        }

        return true;
    });
}

/**
 * @param {string[]} modules
 * @return {string[]}
 */
function getFilesForTranspilation(modules) {
    const root = sanitizePath(path.join(process.cwd(), 'src/**/*.ts'));
    const files = globSync(root, {
        nodir: true,
        ignore: ['**/node_modules/**', '**/framework/modules/**'],
    });

    for (const module of modules) {
        const modulePath = sanitizePath(path.join(process.cwd(), MODULE_FOLDER, module));
        const moduleFiles = globSync(path.join(modulePath, '**/*.ts'), {
            nodir: true,
            ignore: ['**/ui/**'],
        });

        files.push(...moduleFiles);
    }

    return files;
}

/**
 * @param {string[]} modules
 * @return {string[]}
 */
function getFilesToCopy(modules) {
    const filePath = sanitizePath(path.join(process.cwd(), 'src', '**/*.!(ts|svelte)'));
    return globSync(filePath, {
        nodir: true,
        ignore: ['**/tsconfig.json/**', `**/framework/modules/!(${modules.join('|')})/**`],
    });
}

/**
 * @param {string} file
 * @param {string} raw
 * @return {string}
 */
function resolveImports(file, raw) {
    const filePath = file.replace(sanitizePath(process.cwd()), '');
    const pathSplit = filePath.split('/');
    pathSplit.pop();
    let depth = 0;

    while (pathSplit[pathSplit.length - 1] !== 'framework') {
        pathSplit.pop();
        depth++;
    }

    raw = raw.replaceAll('@Framework', `../`.repeat(depth));

    return raw;
}

async function transpileFile(file) {
    const target = file.replace('src', RESOURCES_FOLDER).replace('.ts', '.js');

    let result;
    try {
        result = await swc.transformFile(file, {
            jsc: {
                parser: {
                    syntax: 'typescript',
                    dynamicImport: true,
                    decorators: true,
                },
                transform: {
                    legacyDecorator: true,
                    decoratorMetadata: true,
                },
                target: 'es2020',
            },
            sourceMaps: false,
        });
    } catch (error) {
        console.log(error);
        failedFiles.push(file);
    }

    if (!result) {
        console.warn(`Failed to transpile file: ${file}`);
    }

    if (!result || !result.code) {
        return;
    }

    if (result.code.includes('@Framework')) {
        result.code = resolveImports(result.code);
    }

    const newfile = `// THIS IS A COMPILED FILE. DO NOT EDIT THIS FILE \r\n` + result.code;
    writeFile(target, newfile);
}

async function compileResources() {
    failedFiles = [];
    const modules = getEnabledModules();
    const filesToTransfile = getFilesForTranspilation(modules);
    const filesToCopy = getFilesToCopy(modules);
    const resourceFolder = sanitizePath(path.join(process.cwd(), RESOURCES_FOLDER));

    if (!fs.existsSync(resourceFolder)) {
        fs.mkdirSync(resourceFolder, { recursive: true });
    }

    const filesAndDirectories = fs.readdirSync(resourceFolder);
    for (const fileOrDirectory of filesAndDirectories) {
        const fullPath = sanitizePath(path.join(resourceFolder, fileOrDirectory));
        if (!fullPath.includes('framework') && !fullPath.includes('ui')) continue;

        if (fs.statSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
        }
    }

    for (const file of filesToCopy) {
        const target = file.replace('src', RESOURCES_FOLDER);
        if (file === target) continue;

        copySync(file, target);
    }

    const promises = filesToTransfile.map((file) => transpileFile(file));
    await Promise.all(promises);

    if (failedFiles.length >= 1) {
        for (let failedFile of failedFiles) {
            console.warn(`Failed to transpile file: ${failedFile}`);
        }

        throw new Error(`Failed to transpile ${failedFiles.length} files.`);
    }
}

export { RESOURCES_FOLDER, compileResources, getEnabledModules };
