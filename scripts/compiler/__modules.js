import swc from '@swc/core';
import path, { relative } from 'node:path';
import fs from 'node:fs';
import { sanitizePath, getAllModules, MODULE_FOLDER, globSync, writeFile, copySync } from '../lib/file.js';

let failedFiles = [];
let moduleDisablers = ['disabled'];

const RESOURCES_FOLDER = 'resources/[compiled]';

/**
 * @return {string[]}
 */
function getEnabledModules() {
    const modules = getAllModules();

    return modules.filter((module) => {
        const modulePath = sanitizePath(path.join(MODULE_FOLDER, module));

        for (const file of moduleDisablers) {
            const filePath = sanitizePath(path.join(modulePath, file));

            if (fs.existsSync(filePath)) {
                return false;
            }
        }

        return true;
    });
}

/**
 * @param {string[]} modules
 * @return {string[]}
 */
function getFilesToTranspile(modules) {
    const root = sanitizePath(path.join(process.cwd(), 'src/**/*.ts'));
    const files = globSync(root, {
        nodir: true,
        ignore: ['**/node_modules/**', '**/framework/modules/**'],
    });

    for (const module of modules) {
        const modulePath = sanitizePath(path.join(process.cwd(), MODULE_FOLDER, module));
        const moduleFiles = globSync(path.join(modulePath, '**/*.ts'), {
            nodir: true,
            ignore: ['**/ui/**'],
        });

        files.push(...moduleFiles);
    }

    return files;
}

/**
 * @param {string[]} modules
 * @return {string[]}
 */
function getFilesToCopy(modules) {
    const filePath = sanitizePath(path.join(process.cwd(), 'src', '**/*.!(ts|vue)'));
    return globSync(filePath, {
        nodir: true,
        ignore: ['**/tsconfig.json/**', `**/framework/modules/!(${modules.join('|')})/**`],
    });
}

/**
 * @param {string} file
 * @param {string} raw
 * @return {string}
 */
function resolveImports(file, raw) {
    return raw.replace(/require\(['"](.*?)['"]\)/g, (match, relativePath) => {
        if (relativePath.startsWith('.')) {
            // const absolutePath = path.resolve(path.dirname(file), relativePath);
            const absolutePath = sanitizePath(path.resolve(path.dirname(file), relativePath));
            const extension = path.extname(relativePath) || '.js';
            return `require("${absolutePath}${extension}")`;
        }
        return match;
    });
}

async function generateFxManifests() {
    const resources = globSync(sanitizePath(path.join(process.cwd(), 'src/**/resource.json')), {
        nodir: true,
    });

    for (const resource of resources) {
        const target = resource.replace('src', RESOURCES_FOLDER).replace('.json', '.lua');
        const raw = fs.readFileSync(resource, 'utf8');
        const data = JSON.parse(raw);

        let fxmanifest = `-- THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE \n`;
        for (const [key, value] of Object.entries(data)) {
            if (Array.isArray(value)) {
                fxmanifest += `${key} { \n`;
                for (const item of value) {
                    fxmanifest += `"\t${item} \n"`;
                }
                fxmanifest += `} \n`;
            } else {
                fxmanifest += `${key} "${value}" \n`;
            }
        }

        writeFile(target, fxmanifest);
    }
}

async function transpileFile(file) {
    const target = file.replace('src', RESOURCES_FOLDER).replace('.ts', '.js');

    let result;
    try {
        result = await swc.transformFile(file, {
            module: {
                type: 'commonjs',
            },
            jsc: {
                parser: {
                    syntax: 'typescript',
                    dynamicImport: true,
                    decorators: true,
                },
                transform: {
                    legacyDecorator: true,
                    decoratorMetadata: true,
                },
                target: 'es2020',
            },
            sourceMaps: false,
        });
    } catch (error) {
        console.log(error);
        failedFiles.push(file);
    }

    if (!result) {
        console.warn(`Failed to transpile file: ${file}`);
    }

    if (!result || !result.code) {
        return;
    }

    result.code = resolveImports(target, result.code);

    const newfile = `// THIS IS A COMPILED FILE. DO NOT EDIT THIS FILE \r\n` + result.code;
    writeFile(target, newfile);
}

async function compileModules() {
    failedFiles = [];
    const modules = getEnabledModules();
    const filesToTranspile = getFilesToTranspile(modules);
    const filesToCopy = getFilesToCopy(modules);
    const resourceFolder = sanitizePath(path.join(process.cwd(), RESOURCES_FOLDER));

    if (!fs.existsSync(resourceFolder)) {
        fs.mkdirSync(resourceFolder, { recursive: true });
    }

    const filesAndDirectories = fs.readdirSync(resourceFolder);
    for (const fileOrDirectory of filesAndDirectories) {
        const fullPath = sanitizePath(path.join(resourceFolder, fileOrDirectory));
        if (!fullPath.includes('framework') && !fullPath.includes('ui')) continue;

        if (fs.statSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
        }
    }

    for (const file of filesToCopy) {
        const target = file.replace('src', RESOURCES_FOLDER);
        if (file === target) continue;

        copySync(file, target);
    }

    const promises = filesToTranspile.map((file) => transpileFile(file));
    await Promise.all(promises);

    await generateFxManifests();

    if (failedFiles.length >= 1) {
        for (let failedFile of failedFiles) {
            console.warn(`Failed to transpile file: ${failedFile}`);
        }

        throw new Error(`Failed to transpile ${failedFiles.length} files.`);
    }
}

export { compileModules };
